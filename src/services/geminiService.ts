import { GoogleGenerativeAI } from '@google/generative-ai';
import { GEMINI_CONFIG } from '../config/gemini';

export interface GeminiMessage {
  role: 'user' | 'model';
  parts: { text: string }[];
}

export interface GeminiResponse {
  candidates: {
    content: {
      parts: { text: string }[];
    };
  }[];
}

export class GeminiService {
  private genAI: GoogleGenerativeAI;
  private model: any;

  constructor() {
    this.genAI = new GoogleGenerativeAI(GEMINI_CONFIG.apiKey);
    this.model = this.genAI.getGenerativeModel({ 
      model: GEMINI_CONFIG.modelName,
      generationConfig: GEMINI_CONFIG.generationConfig
    });
  }

  private extractTextSafely(result: any): string {
    try {
      const text = result?.response?.text?.() ?? '';
      if (text && typeof text === 'string' && text.trim().length > 0) return text;
    } catch {}

    try {
      const candidates = result?.response?.candidates || result?.candidates;
      const firstText = candidates?.[0]?.content?.parts?.[0]?.text;
      if (firstText && typeof firstText === 'string' && firstText.trim().length > 0) return firstText;
    } catch {}

    return '';
  }

  async generateContent(prompt: string): Promise<string> {
    try {
      console.log(`ü§ñ G√©n√©ration de contenu avec ${GEMINI_CONFIG.modelName}...`);
      
      // Ajouter un timeout pour √©viter les attentes trop longues
      const timeoutPromise = new Promise<never>((_, reject) => {
        setTimeout(() => reject(new Error('Timeout: La requ√™te a pris trop de temps')), 30000); // 30 secondes
      });
      
      const generatePromise = this.model.generateContent(prompt);
      const result = await Promise.race([generatePromise, timeoutPromise]);
      const text = this.extractTextSafely(result);
      
      console.log('‚úÖ R√©ponse g√©n√©r√©e avec succ√®s');
      return text && text.trim().length > 0
        ? text
        : 'Je suis d√©sol√©, je ne peux pas r√©pondre √† votre question pour le moment.';
    } catch (error) {
      console.error('‚ùå Erreur lors de la g√©n√©ration de contenu:', error);
      
      // Retourner une r√©ponse de fallback en cas d'erreur
      if (error instanceof Error && error.message.includes('Timeout')) {
        return "D√©sol√©, je rencontre des difficult√©s techniques. Veuillez r√©essayer dans quelques instants.";
      }
      
      return "Je suis d√©sol√©, je ne peux pas r√©pondre √† votre question pour le moment. Veuillez r√©essayer plus tard.";
    }
  }

  async chatWithAI(messages: GeminiMessage[]): Promise<string> {
    try {
      console.log(`üí¨ Chat avec ${GEMINI_CONFIG.modelName}...`);
      
      // Ajouter un timeout pour √©viter les attentes trop longues
      const timeoutPromise = new Promise<never>((_, reject) => {
        setTimeout(() => reject(new Error('Timeout: La requ√™te de chat a pris trop de temps')), 30000); // 30 secondes
      });
      
      // Convertir les messages au format attendu par la nouvelle API
      const chat = this.model.startChat({
        history: messages.slice(0, -1).map(msg => ({
          role: msg.role === 'user' ? 'user' : 'model',
          parts: msg.parts
        }))
      });
      
      const lastMessage = messages[messages.length - 1];
      const chatPromise = chat.sendMessage(lastMessage.parts[0].text);
      const result = await Promise.race([chatPromise, timeoutPromise]);
      const text = this.extractTextSafely(result);
      
      console.log('‚úÖ R√©ponse de chat g√©n√©r√©e avec succ√®s');
      return text && text.trim().length > 0
        ? text
        : 'Je suis d√©sol√©, je ne peux pas r√©pondre √† votre question pour le moment.';
    } catch (error) {
      console.error('‚ùå Erreur lors du chat avec l\'IA:', error);
      
      // Retourner une r√©ponse de fallback en cas d'erreur
      if (error instanceof Error && error.message.includes('Timeout')) {
        return "D√©sol√©, je rencontre des difficult√©s techniques. Veuillez r√©essayer dans quelques instants.";
      }
      
      return "Je suis d√©sol√©, je ne peux pas r√©pondre √† votre question pour le moment. Veuillez r√©essayer plus tard.";
    }
  }

  async generateContentWithImage(prompt: string, imageData: string): Promise<string> {
    try {
      console.log('üñºÔ∏è G√©n√©ration de contenu avec image...');
      
      // Ajouter un timeout pour √©viter les attentes trop longues
      const timeoutPromise = new Promise<never>((_, reject) => {
        setTimeout(() => reject(new Error('Timeout: La requ√™te avec image a pris trop de temps')), 30000); // 30 secondes
      });
      
      const imagePromise = this.model.generateContent([
        prompt,
        {
          inlineData: {
            data: imageData,
            mimeType: 'image/jpeg'
          }
        }
      ]);
      
      const result = await Promise.race([imagePromise, timeoutPromise]);
      const text = this.extractTextSafely(result);
      
      console.log('‚úÖ R√©ponse avec image g√©n√©r√©e avec succ√®s');
      return text && text.trim().length > 0
        ? text
        : 'Je suis d√©sol√©, je ne peux pas analyser cette image pour le moment.';
    } catch (error) {
      console.error('‚ùå Erreur lors de la g√©n√©ration avec image:', error);
      
      // Retourner une r√©ponse de fallback en cas d'erreur
      if (error instanceof Error && error.message.includes('Timeout')) {
        return "D√©sol√©, je rencontre des difficult√©s techniques avec l'analyse de l'image. Veuillez r√©essayer dans quelques instants.";
      }
      
      return "Je suis d√©sol√©, je ne peux pas analyser cette image pour le moment. Veuillez r√©essayer plus tard.";
    }
  }
}

export const geminiService = new GeminiService();
